<script>
  function toggleMatch(matchId) {
    const card = document.getElementById(matchId);
    card.classList.toggle('active');
    saveOpenMatches();
  }
  
  function saveOpenMatches() {
    const openMatches = Array.from(document.querySelectorAll('.match-card.active')).map(card => card.id);
    localStorage.setItem('openMatches', JSON.stringify(openMatches));
  }
  
  function restoreOpenMatches() {
    const stored = localStorage.getItem('openMatches');
    if (stored) {
      const openMatches = JSON.parse(stored);
      openMatches.forEach(matchId => {
        const card = document.getElementById(matchId);
        if (card) card.classList.add('active');
      });
    }
  }
  
  // Find the next match card (first non-completed match)
  function findNextMatchCard() {
    // First check for Currently Playing matches
    let matchGroups = document.querySelectorAll('.match-group');
    for (const group of matchGroups) {
      const groupTitle = group.querySelector('.match-group-title');
      if (groupTitle && groupTitle.textContent.includes('Currently Playing')) {
        const cards = group.querySelectorAll('.match-card');
        if (cards.length > 0) return cards[0];
      }
    }
    
    // Then check for Next Up matches
    for (const group of matchGroups) {
      const groupTitle = group.querySelector('.match-group-title');
      if (groupTitle && groupTitle.textContent.includes('Next Up')) {
        const cards = group.querySelectorAll('.match-card');
        if (cards.length > 0) return cards[0];
      }
    }
    
    // Finally check for any non-completed match
    const allMatchCards = document.querySelectorAll('.match-card');
    for (const card of allMatchCards) {
      if (!card.closest('.match-group').querySelector('.match-group-title').textContent.includes('Completed')) {
        return card;
      }
    }
    
    return null;
  }
  
  // Auto-open the next match card
  function openNextMatchCard() {
    const nextMatchCard = findNextMatchCard();
    if (nextMatchCard) {
      console.log('Found next match card:', nextMatchCard.id);
      nextMatchCard.classList.add('active');
      saveOpenMatches();
      
      // Scroll to the next match card
      nextMatchCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      return nextMatchCard;
    } else {
      console.log('No next match card found');
      return null;
    }
  }
  
  // Collapse all match cards except for the next match
  function collapseOtherMatchCards(nextMatchCard) {
    if (!nextMatchCard) return;
    
    console.log('Collapsing matches except:', nextMatchCard.id);
    const allMatchCards = document.querySelectorAll('.match-card.active');
    allMatchCards.forEach(card => {
      if (card.id !== nextMatchCard.id) {
        card.classList.remove('active');
      }
    });
    saveOpenMatches();
  }
  
  let currentDataHash = "";
  let checkInterval = 10000; // 10 seconds interval
  let updateTimer;
  let serverTimeOffset = 0; // Store the difference between server and client time
  let collapseTimer; // Timer for collapsing other match cards
  let autoOpenedMatchId = null; // Track the automatically opened match
  
  // Check if client clock is synchronized with EST
  function checkClockSync(serverTimestamp) {
    const clientTime = Date.now();
    const timeDiff = Math.abs(clientTime - serverTimestamp);
    
    if (timeDiff > 5000) { // More than 5 seconds difference
      console.log(`Clock desync detected: ${timeDiff}ms difference`);
      serverTimeOffset = serverTimestamp - clientTime;
      
      // Add a warning to the UI
      const updateStatus = document.getElementById('update-status');
      if (updateStatus) {
        updateStatus.innerHTML += ` <span style="color: #ff9800;">(Clock desync detected: ${Math.round(timeDiff/1000)}s)</span>`;
      }
      
      // Update any time displays that might be on the page
      updateSyncedClock();
      return false;
    }
    return true;
  }
  
  // Get the current time adjusted for any server-client difference
  function getSyncedTime() {
    return new Date(Date.now() + serverTimeOffset);
  }
  
  // Update any clock elements on the page with the synced time
  function updateSyncedClock() {
    const clockTime = document.getElementById('clock-time');
    const clockDate = document.getElementById('clock-date');
    
    if (clockTime && clockDate) {
      const syncedNow = getSyncedTime();
      
      clockTime.textContent = syncedNow.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
      });
      
      clockDate.textContent = syncedNow.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    }
  }
  
  // Initialize auto-opening functionality
  function initializeMatchDisplay() {
    console.log('Initializing match display behavior');
    
    // Clear any existing collapse timer
    if (collapseTimer) {
      clearTimeout(collapseTimer);
    }
    
    // Automatically open the next match card
    const nextMatchCard = openNextMatchCard();
    
    // Store the ID of the automatically opened match card
    if (nextMatchCard) {
      autoOpenedMatchId = nextMatchCard.id;
      console.log('Auto-opened match ID:', autoOpenedMatchId);
    }
  }
  
  // Check if a match is completed
  function isMatchCompleted(matchId) {
    const card = document.getElementById(matchId);
    if (!card) return false;
    
    // Check if the match card is in a completed group
    const group = card.closest('.match-group');
    if (!group) return false;
    
    const groupTitle = group.querySelector('.match-group-title');
    return groupTitle && groupTitle.textContent.includes('Completed');
  }
  
  // Close a match card
  function closeMatchCard(matchId) {
    const card = document.getElementById(matchId);
    if (card && card.classList.contains('active')) {
      console.log('Closing completed match card:', matchId);
      card.classList.remove('active');
      saveOpenMatches();
    }
  }
  // SSE connection for real-time updates
  let eventSource = null;
  let reconnectAttempts = 0;
  const maxReconnectAttempts = 5;
  let fallbackToPolling = false;

  function initializeSSE() {
    const updateStatus = document.getElementById('update-status');
    const hashDisplay = document.getElementById('hash-display');
    
    if (eventSource) {
      eventSource.close();
    }

    const sseUrl = '/api/updates-stream?eventKey=' + encodeURIComponent('<%= eventKey %>') 
      + '&teamKey=' + encodeURIComponent('<%= formattedTeamKey %>');
    
    console.log('Attempting SSE connection to:', sseUrl);
    eventSource = new EventSource(sseUrl);
    
    eventSource.onopen = function() {
      console.log('SSE connection opened');
      reconnectAttempts = 0;
      fallbackToPolling = false;
      updateStatus.innerHTML = 'Connected to real-time updates';
    };
    
    eventSource.onmessage = function(event) {
      try {
        const data = JSON.parse(event.data);
        console.log('SSE message received:', data.type);
        
        if (data.type === 'connected') {
          console.log('SSE connected successfully');
          updateStatus.innerHTML = 'Real-time updates active';
        } else if (data.type === 'update') {
          console.log('Received update via SSE');
          handleRealtimeUpdate();
        } else if (data.type === 'heartbeat') {
          // Update last seen timestamp
          const lastChecked = getSyncedTime().toLocaleTimeString();
          updateStatus.innerHTML = 'Data provided by FIRST Nexus & TBA APIs' + ' • Last update: ' + lastChecked;
          checkClockSync(data.timestamp);
        }
      } catch (error) {
        console.error('Error parsing SSE data:', error);
      }
    };
    
    eventSource.onerror = function(error) {
      console.error('SSE error:', error);
      updateStatus.innerHTML = 'Connection error. Attempting to reconnect...';
      
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        setTimeout(() => {
          console.log(`Reconnecting SSE (attempt ${reconnectAttempts})`);
          initializeSSE();
        }, 1000 * reconnectAttempts);
      } else {
        console.log('SSE failed, falling back to polling');
        updateStatus.innerHTML = 'Using fallback updates...';
        fallbackToPolling = true;
        setTimeout(checkForUpdates, 5000);
      }
    };
  }

  async function handleRealtimeUpdate() {
    const updateStatus = document.getElementById('update-status');
    
    try {
      console.log('Handling realtime update');
      // Fetch the processed match data
      const response = await fetch('/api/current-matches?eventKey=' + encodeURIComponent('<%= eventKey %>') 
        + '&teamKey=' + encodeURIComponent('<%= formattedTeamKey %>'));
      
      if (!response.ok) {
        throw new Error('Failed to fetch current matches');
      }
      
      const data = await response.json();
      console.log('Received updated match data');
      
      // Save currently open matches
      saveOpenMatches();
      
      // Update the UI with new data
      updateMatchesUI(data);
      updateEventInfo(data.nowQueuing);
      updateTeamRanking(data.teamRanking);
      
      // Check if the auto-opened match is now completed
      if (autoOpenedMatchId && isMatchCompleted(autoOpenedMatchId)) {
        closeMatchCard(autoOpenedMatchId);
        autoOpenedMatchId = null;
        
        // Automatically open the next match card
        const nextMatchCard = openNextMatchCard();
        if (nextMatchCard) {
          autoOpenedMatchId = nextMatchCard.id;
        }
      }
      
      // Restore open matches
      restoreOpenMatches();
      
      const lastChecked = getSyncedTime().toLocaleTimeString();
      updateStatus.innerHTML = 'Data provided by FIRST Nexus & TBA APIs' + ' • Last update: ' + lastChecked;
      
    } catch (error) {
      console.error('Error handling realtime update:', error);
      updateStatus.innerHTML = 'Update failed. Retrying...';
    }
  }
  // Fallback polling function (used if SSE fails)
  async function checkForUpdates() {
    const updateStatus = document.getElementById('update-status');
    const hashDisplay = document.getElementById('hash-display');
    
    // Don't run polling if SSE is working
    if (!fallbackToPolling) {
      return;
    }
    
    try {
      updateStatus.innerHTML = 'Checking for updates...';
      const response = await fetch('/api/data-check?eventKey=' + encodeURIComponent('<%= eventKey %>') 
        + '&teamKey=' + encodeURIComponent('<%= formattedTeamKey %>') 
        + '&lastUpdate=' + currentDataHash);
      const data = await response.json();
      
      // Check clock sync using server timestamp
      if (data.timestamp) {
        checkClockSync(data.timestamp);
      }
      
      if (data.changed) {
        console.log('Polling detected changes, updating UI');
        handleRealtimeUpdate();
      } else {
        // Check if the auto-opened match is now completed
        if (autoOpenedMatchId && isMatchCompleted(autoOpenedMatchId)) {
          closeMatchCard(autoOpenedMatchId);
          autoOpenedMatchId = null; // Reset after closing
          
          // Automatically open the next match card
          const nextMatchCard = openNextMatchCard();
          if (nextMatchCard) {
            autoOpenedMatchId = nextMatchCard.id;
          }
        }
        
        currentDataHash = data.hash;
        const shortHash = currentDataHash.substring(0, 8);
        const lastChecked = getSyncedTime().toLocaleTimeString();
        updateStatus.innerHTML = 'Data provided by FIRST Nexus & TBA APIs' + ' • Last checked: ' + lastChecked;
        if (hashDisplay) hashDisplay.innerHTML = 'Hash: ' + shortHash;
      }
      
      // Continue polling if we're in fallback mode
      if (fallbackToPolling) {
        updateTimer = setTimeout(checkForUpdates, checkInterval);
      }
    } catch (error) {
      console.error('Error checking for updates:', error);
      updateStatus.innerHTML = 'Update check failed. Retrying soon...';
      if (fallbackToPolling) {
        updateTimer = setTimeout(checkForUpdates, checkInterval * 2);
      }
    }
  }
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM fully loaded - Initializing match system');
    
    // Wait a short time to ensure all elements are fully rendered
    setTimeout(() => {
      initializeMatchDisplay();
    }, 100);
    
    // Try SSE first, with fallback to polling
    setTimeout(() => {
      console.log('Initializing update system...');
      
      // Check if SSE is supported
      if (typeof(EventSource) !== "undefined") {
        console.log('SSE supported, attempting connection');
        initializeSSE();
      } else {
        console.log('SSE not supported, falling back to polling');
        fallbackToPolling = true;
        checkForUpdates();
      }
    }, 1000);
    
    // Start clock updates
    updateSyncedClock();
    setInterval(updateSyncedClock, 1000);
    
    // Handle page visibility changes
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        console.log('Page visible, reconnecting if needed');
        // Reconnect SSE if page becomes visible and not using polling
        if (!fallbackToPolling && (!eventSource || eventSource.readyState === EventSource.CLOSED)) {
          initializeSSE();
        }
      } else {
        console.log('Page hidden, closing SSE connection');
        // Close SSE connection when page is hidden to save resources
        if (eventSource) {
          eventSource.close();
        }
        // Clear any polling timers
        if (updateTimer) {
          clearTimeout(updateTimer);
        }
      }
    });
    
    // Handle page unload
    window.addEventListener('beforeunload', () => {
      if (eventSource) {
        eventSource.close();
      }
      if (updateTimer) {
        clearTimeout(updateTimer);
      }
    });
  });
  
  // Format all timestamps to local timezone
  function formatAllTimestamps() {
    console.log("Running timestamp formatter");
    
    // Format match header times
    document.querySelectorAll('[data-timestamp]').forEach(el => {
      const timestamp = el.getAttribute('data-timestamp');
      console.log("Processing timestamp:", timestamp, "for element:", el.className);
      
      // Check if timestamp exists and is valid
      if (timestamp && timestamp !== "null" && timestamp !== "undefined" && timestamp !== "") {
        try {
          // Try parsing the timestamp - support both ISO strings and Unix timestamps
          let date;
          
          // If it's a number (unix timestamp in milliseconds), convert it
          if (!isNaN(timestamp) && timestamp.length > 10) {
            date = new Date(parseInt(timestamp));
          } else {
            // Otherwise treat as ISO string
            date = new Date(timestamp);
          }
          
          console.log("Parsed date:", date);
          
          if (!isNaN(date.getTime())) {
            // Format the valid date
            el.textContent = date.toLocaleTimeString('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true
            });
            console.log("Formatted time:", el.textContent);
          } else {
            console.log("Invalid date after parsing:", date);
            // For debugging, show the raw timestamp
            el.textContent = "TBD [Invalid: " + timestamp.substring(0, 30) + "]";
          }
        } catch (e) {
          console.error("Error formatting timestamp:", timestamp, e);
          el.textContent = "TBD [Error]";
        }
      } else {
        console.log("Empty or null timestamp");
        el.textContent = "TBD";
      }
    });
  }
  
  // Call when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM loaded, formatting timestamps");
    formatAllTimestamps();
  });
  
  // UI update functions for SSE
  function updateMatchesUI(data) {
    const matchesColumn = document.querySelector('.matches-column .content');
    if (!matchesColumn) return;

    // Generate new HTML for matches
    let newHTML = '';
    
    // Handle empty matches case
    if (Object.keys(data.matchGroups).length === 0 && data.completedMatches.length === 0) {
      newHTML = `
        <div class="no-matches">
          <p>No matches found for team <%= formattedTeamKey %></p>
        </div>
      `;
    } else {
      // Active/Upcoming Matches
      Object.keys(data.matchGroups).forEach(groupType => {
        newHTML += generateMatchGroupHTML(groupType, data.matchGroups[groupType], false);
      });
      
      // Completed Matches
      if (data.completedMatches.length > 0) {
        newHTML += generateMatchGroupHTML('Completed', data.completedMatches, true);
      }
    }
    
    matchesColumn.innerHTML = newHTML;
    
    // Re-run timestamp formatting for new content
    formatAllTimestamps();
  }

  function updateEventInfo(nowQueuing) {
    const nowQueuingElement = document.querySelector('.now-queuing');
    if (nowQueuingElement && nowQueuing) {
      nowQueuingElement.textContent = 'Now Queuing: ' + nowQueuing;
    }
  }

  function updateTeamRanking(teamRanking) {
    if (!teamRanking) return;
    
    const rankElement = document.querySelector('.stat-card .stat-value');
    const recordElement = document.querySelectorAll('.stat-card .stat-value')[1];
    const matchesPlayedElement = document.querySelectorAll('.stat-card .stat-value')[2];
    
    if (rankElement) rankElement.textContent = '#' + teamRanking.rank;
    if (recordElement) recordElement.textContent = teamRanking.record;
    if (matchesPlayedElement) matchesPlayedElement.textContent = teamRanking.matchesPlayed || "N/A";
  }

  function generateMatchGroupHTML(groupType, matches, isCompletedGroup) {
    if (!matches || matches.length === 0) return '';
    
    const formattedTeamKey = '<%= formattedTeamKey %>';
    
    let html = `
      <div class="match-group">
        <div class="match-group-title">${groupType}</div>
        <div class="match-group-content">
    `;
    
    matches.forEach(match => {
      const redTeams = match.redTeams || [];
      const blueTeams = match.blueTeams || [];
      const isTeamInMatch = redTeams.includes(formattedTeamKey) || blueTeams.includes(formattedTeamKey);
      const alliance = redTeams.includes(formattedTeamKey) ? 'red' : 'blue';
      
      const matchId = match.label.replace(/\s+/g, '-');
      
      html += `
        <div id="${matchId}" class="match-card ${isTeamInMatch ? 'team-match' : ''} ${isCompletedGroup ? 'completed' : ''}" onclick="toggleMatch('${matchId}')">
          <div class="match-header">
            <div class="match-info">
              <span class="match-name">${match.label}</span>
              <span class="match-time" data-timestamp="${match.times?.scheduledStartTime || ''}">
                ${formatMatchTime(match.times?.scheduledStartTime)}
              </span>
            </div>
            <div class="match-status ${getStatusClass(match.status)}">${match.status}</div>
          </div>
          
          <div class="match-details">
            <div class="alliances">
              <div class="alliance red">
                <div class="alliance-label">Red Alliance</div>
                <div class="teams">
                  ${redTeams.map(team => `
                    <span class="team ${team === formattedTeamKey ? 'highlighted' : ''}">${team}</span>
                  `).join('')}
                </div>
                ${match.scores?.red !== undefined ? `<div class="score">${match.scores.red}</div>` : ''}
              </div>
              
              <div class="alliance blue">
                <div class="alliance-label">Blue Alliance</div>
                <div class="teams">
                  ${blueTeams.map(team => `
                    <span class="team ${team === formattedTeamKey ? 'highlighted' : ''}">${team}</span>
                  `).join('')}
                </div>
                ${match.scores?.blue !== undefined ? `<div class="score">${match.scores.blue}</div>` : ''}
              </div>
            </div>
            
            ${match.rankingPoints ? `
              <div class="ranking-points">
                <div class="rp-section red">
                  <span class="rp-label">Red RP:</span>
                  <span class="rp-value">${match.rankingPoints.red}</span>
                </div>
                <div class="rp-section blue">
                  <span class="rp-label">Blue RP:</span>
                  <span class="rp-value">${match.rankingPoints.blue}</span>
                </div>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    });
    
    html += `
        </div>
      </div>
    `;
    
    return html;
  }

  function formatMatchTime(timestamp) {
    if (!timestamp || timestamp === "null" || timestamp === "undefined" || timestamp === "") {
      return "TBD";
    }
    
    try {
      let date;
      if (!isNaN(timestamp) && timestamp.length > 10) {
        date = new Date(parseInt(timestamp));
      } else {
        date = new Date(timestamp);
      }
      
      if (!isNaN(date.getTime())) {
        return date.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
      }
    } catch (e) {
      console.error("Error formatting timestamp:", timestamp, e);
    }
    
    return "TBD";
  }

  function getStatusClass(status) {
    if (!status) return 'status-default';
    
    const statusLower = status.toLowerCase();
    if (statusLower.includes('queuing')) return 'status-queuing';
    if (statusLower.includes('deck')) return 'status-on-deck';
    if (statusLower.includes('field')) return 'status-on-field';
    if (statusLower.includes('completed')) return 'status-completed';
    return 'status-default';
  }
</script>